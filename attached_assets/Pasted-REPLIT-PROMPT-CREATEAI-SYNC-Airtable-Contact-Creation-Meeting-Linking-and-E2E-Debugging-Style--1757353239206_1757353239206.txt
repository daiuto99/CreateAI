REPLIT PROMPT — CREATEAI SYNC: Airtable Contact Creation, Meeting Linking, and E2E Debugging
Style: clean, minimalist, production-ready. Paste this whole prompt into Replit “⬇️ Generate Code” and let it create/overwrite files as listed.

──────────────────────────────────────────────────────────────────────────────
OBJECTIVE
Add a minimal, robust SYNC pipeline that:
1) Ingests meeting payloads (from Zapier/Airtable/Otter).
2) Extracts/creates/updates a Contact in Airtable.
3) Creates/links a Meeting + Transcript in Airtable.
4) Is idempotent (no dupes), has clear logs, and has a one-click reprocess path.

We’ll ONLY touch files shown in your repo tree. New files go into server/services and shared.

──────────────────────────────────────────────────────────────────────────────
ENV VARS (set in Replit Secrets)
AIRTABLE_API_KEY = <your key>
AIRTABLE_BASE_ID = <base id>
AIRTABLE_CONTACTS_TABLE = Contacts
AIRTABLE_MEETINGS_TABLE = Meetings
AIRTABLE_TRANSCRIPTS_TABLE = Transcripts

(Optional)
APP_TZ = America/New_York  // used only for display; writes stay UTC

──────────────────────────────────────────────────────────────────────────────
CREATE these files:

1) server/services/logger.ts
──────────────────────────────────────────────────────────────────────────────
import { randomUUID } from 'crypto';

type Fields = Record<string, unknown>;
type Level = 'info' | 'warn' | 'error' | 'debug';

export function requestId(req: any, _res: any, next: any) {
  req.correlationId = req.headers['x-correlation-id'] || randomUUID();
  next();
}

function line(level: Level, msg: string, extra: Fields = {}) {
  const base = {
    ts: new Date().toISOString(),
    level,
    msg,
    ...extra,
  };
  // Single-line JSON for easy grep/ingest
  return JSON.stringify(base);
}

export const log = {
  info: (msg: string, extra?: Fields) => console.log(line('info', msg, extra)),
  warn: (msg: string, extra?: Fields) => console.warn(line('warn', msg, extra)),
  error: (msg: string, extra?: Fields) => console.error(line('error', msg, extra)),
  debug: (msg: string, extra?: Fields) => console.log(line('debug', msg, extra)),
};

export function withCtx(req: any, fields: Fields = {}) {
  return { ...fields, correlationId: req.correlationId };
}
──────────────────────────────────────────────────────────────────────────────

2) shared/types.ts
(If shared/ already has types, extend it. Otherwise create this file.)
──────────────────────────────────────────────────────────────────────────────
export type SyncSource = 'otter' | 'manual';

export interface InboundMeetingPayload {
  source: SyncSource;                 // 'otter' recommended
  externalMeetingId: string;          // unique from Otter/Zap
  title?: string;
  startISO?: string;
  endISO?: string;
  attendees?: Array<{ name?: string; email?: string; phone?: string; company?: string }>;
  transcript?: string;                // meeting summary/full text
  notes?: string;                     // optional
  raw?: unknown;                      // full Zap payload (for Needs Review)
}

export interface ContactInput {
  name?: string;
  email?: string;
  phone?: string;
  company?: string;
  status?: 'Active' | 'Prospect' | 'Unknown' | 'Needs Review';
}

export interface MeetingResult {
  meetingRecordId: string;
  contactRecordId?: string;
  transcriptRecordId?: string;
  created: boolean;
  linked: boolean;
}
──────────────────────────────────────────────────────────────────────────────

3) server/services/airtable.ts
(Uses global fetch on Node 18+; no extra deps.)
──────────────────────────────────────────────────────────────────────────────
const AIRTABLE_API = 'https://api.airtable.com/v0';

const BASE_ID = process.env.AIRTABLE_BASE_ID!;
const CONTACTS = process.env.AIRTABLE_CONTACTS_TABLE || 'Contacts';
const MEETINGS = process.env.AIRTABLE_MEETINGS_TABLE || 'Meetings';
const TRANSCRIPTS = process.env.AIRTABLE_TRANSCRIPTS_TABLE || 'Transcripts';
const KEY = process.env.AIRTABLE_API_KEY!;

function assertEnv() {
  if (!BASE_ID || !KEY) {
    throw new Error('[config] Missing AIRTABLE_BASE_ID or AIRTABLE_API_KEY');
  }
}

async function api(path: string, init: RequestInit = {}) {
  assertEnv();
  const res = await fetch(`${AIRTABLE_API}/${BASE_ID}/${encodeURIComponent(path)}`, {
    ...init,
    headers: {
      Authorization: `Bearer ${KEY}`,
      'Content-Type': 'application/json',
      ...(init.headers || {}),
    },
  });
  if (!res.ok) {
    const text = await res.text();
    throw new Error(`Airtable ${path} ${res.status}: ${text}`);
  }
  return res.json() as Promise<any>;
}

export const airtable = {
  searchContactsByEmail: async (email: string) => {
    const q = encodeURIComponent(`LOWER({Email}) = "${email.toLowerCase()}"`);
    const data = await api(`${CONTACTS}?filterByFormula=${q}`);
    return (data.records ?? []) as Array<{ id: string; fields: Record<string, any> }>;
  },

  createOrUpdateContact: async (fields: Record<string, any>, recordId?: string) => {
    if (recordId) {
      return api(CONTACTS, {
        method: 'PATCH',
        body: JSON.stringify({ records: [{ id: recordId, fields }] }),
      });
    }
    return api(CONTACTS, {
      method: 'POST',
      body: JSON.stringify({ records: [{ fields }] }),
    });
  },

  createMeeting: async (fields: Record<string, any>) => {
    return api(MEETINGS, {
      method: 'POST',
      body: JSON.stringify({ records: [{ fields }] }),
    });
  },

  linkMeetingToContact: async (meetingRecordId: string, contactRecordId: string) => {
    return api(MEETINGS, {
      method: 'PATCH',
      body: JSON.stringify({
        records: [{ id: meetingRecordId, fields: { Contact: [contactRecordId] } }],
      }),
    });
  },

  createTranscript: async (fields: Record<string, any>) => {
    return api(TRANSCRIPTS, {
      method: 'POST',
      body: JSON.stringify({ records: [{ fields }] }),
    });
  },
};
──────────────────────────────────────────────────────────────────────────────

4) server/services/sync.ts
(Business logic: extract contact, idempotency key, create/link)
──────────────────────────────────────────────────────────────────────────────
import { airtable } from './airtable';
import { log, withCtx } from './logger';
import type { InboundMeetingPayload, ContactInput, MeetingResult } from '../../shared/types';

function normalizePhone(phone?: string) {
  if (!phone) return undefined;
  const d = phone.replace(/\D/g, '');
  if (d.length === 10) return `+1${d}`;
  if (d.startsWith('1') && d.length === 11) return `+${d}`;
  if (phone.startsWith('+')) return phone;
  return `+${d}`;
}

export function extractContactFromMeeting(p: InboundMeetingPayload): ContactInput | undefined {
  const att = (p.attendees ?? []).find(a => a.email || a.phone || a.name || a.company);
  if (!att) return undefined;
  return {
    name: att.name?.trim(),
    email: att.email?.trim(),
    phone: normalizePhone(att.phone),
    company: att.company?.trim(),
    status: 'Prospect',
  };
}

// Deterministic idempotency key (store in Airtable Meeting fields)
function idemKey(p: InboundMeetingPayload) {
  const start = p.startISO ?? '';
  return `${p.source}:${p.externalMeetingId}:${start}`;
}

export async function processMeeting(req: any, payload: InboundMeetingPayload): Promise<MeetingResult> {
  const ctx = withCtx(req, { idem: idemKey(payload) });
  log.info('sync.process.start', ctx);

  // 1) Contact matching/creation
  let contactRecordId: string | undefined;
  const candidate = extractContactFromMeeting(payload);

  if (candidate?.email) {
    const existing = await airtable.searchContactsByEmail(candidate.email);
    if (existing.length > 0) {
      contactRecordId = existing[0].id;
      log.info('contact.match.email', withCtx(req, { contactRecordId, email: candidate.email }));
      // Optional: update fields if empty in Airtable
      await airtable.createOrUpdateContact(
        {
          Name: candidate.name ?? existing[0].fields['Name'],
          Email: candidate.email,
          Phone: candidate.phone ?? existing[0].fields['Phone'],
          Company: candidate.company ?? existing[0].fields['Company'],
          Status: existing[0].fields['Status'] ?? candidate.status ?? 'Prospect',
        },
        contactRecordId
      );
    } else {
      const created = await airtable.createOrUpdateContact({
        Name: candidate.name ?? 'Unknown',
        Email: candidate.email,
        Phone: candidate.phone,
        Company: candidate.company,
        Status: candidate.status ?? 'Prospect',
      });
      contactRecordId = created.records?.[0]?.id;
      log.info('contact.created', withCtx(req, { contactRecordId, email: candidate.email }));
    }
  } else if (candidate) {
    // Minimal-fields fallback path
    const created = await airtable.createOrUpdateContact({
      Name: candidate.name ?? 'Unknown',
      Phone: candidate.phone,
      Company: candidate.company,
      Status: 'Needs Review',
    });
    contactRecordId = created.records?.[0]?.id;
    log.warn('contact.created.minimal', withCtx(req, { contactRecordId }));
  } else {
    log.warn('contact.none.extracted', ctx);
  }

  // 2) Transcript creation (optional but recommended)
  let transcriptRecordId: string | undefined;
  if (payload.transcript || payload.notes || payload.raw) {
    const t = await airtable.createTranscript({
      Title: payload.title ?? 'Meeting Transcript',
      Content: payload.transcript ?? JSON.stringify(payload.raw ?? {}, null, 2),
      'Meeting Date': payload.startISO ? new Date(payload.startISO).toISOString() : undefined,
      'Processing Status': 'Processed',
    });
    transcriptRecordId = t.records?.[0]?.id;
    log.info('transcript.created', withCtx(req, { transcriptRecordId }));
  }

  // 3) Meeting creation (idempotency fields live on the record)
  const meetingWrite = await airtable.createMeeting({
    Name: payload.title ?? 'Meeting',
    'External Meeting ID': payload.externalMeetingId,
    Source: payload.source,
    'Idempotency Key': idemKey(payload),
    'Meeting Date': payload.startISO ? new Date(payload.startISO).toISOString() : undefined,
    Status: 'Processed',
    Transcript: transcriptRecordId ? [transcriptRecordId] : undefined,
    // Contact link added next after we get the record id
  });

  const meetingRecordId = meetingWrite.records?.[0]?.id as string;
  log.info('meeting.created', withCtx(req, { meetingRecordId }));

  // 4) Link meeting → contact if present
  if (meetingRecordId && contactRecordId) {
    await airtable.linkMeetingToContact(meetingRecordId, contactRecordId);
    log.info('meeting.linked.contact', withCtx(req, { meetingRecordId, contactRecordId }));
  } else {
    log.warn('meeting.not_linked_contact', withCtx(req, { meetingRecordId, contactRecordId }));
  }

  log.info('sync.process.done', ctx);
  return {
    meetingRecordId,
    contactRecordId,
    transcriptRecordId,
    created: true,
    linked: Boolean(contactRecordId),
  };
}
──────────────────────────────────────────────────────────────────────────────

5) PATCH server/services/routes.ts
(Add three endpoints: ingest, meeting details, reprocess)
──────────────────────────────────────────────────────────────────────────────
import type { Express, Request, Response } from 'express';
import { requestId, log, withCtx } from './logger';
import { processMeeting } from './sync';

// NOTE: Your file already exports a function that wires routes to an Express app.
// If not, adapt accordingly.
export function registerRoutes(app: Express) {
  app.use(requestId);

  // --- existing routes remain unchanged ---

  // 1) Ingest endpoint (Zapier → your app)
  app.post('/api/sync/ingest', async (req: Request, res: Response) => {
    try {
      const result = await processMeeting(req, req.body);
      return res.status(200).json({ ok: true, result });
    } catch (err: any) {
      log.error('sync.ingest.error', withCtx(req, { err: err.message }));
      return res.status(500).json({ ok: false, error: err.message });
    }
  });

  // 2) Meeting details (stub – wire to your DB or Airtable as needed)
  app.get('/api/meetings/:id', async (req: Request, res: Response) => {
    // If you later mirror Airtable meetings into your DB, read from DB here.
    // For now, return a simple payload so the modal renders.
    return res.json({
      id: req.params.id,
      title: 'Meeting',
      status: 'Processed',
    });
  });

  // 3) Reprocess (admin button can call this to retry)
  app.post('/api/sync/reprocess/:transcriptId', async (req: Request, res: Response) => {
    // In a fuller build, fetch the original raw payload by transcriptId (or a DLQ table) and call processMeeting again.
    // Placeholder response for wiring the UI:
    return res.json({ ok: true, reprocessed: req.params.transcriptId });
  });
}
──────────────────────────────────────────────────────────────────────────────

6) VERIFY server/services/index.ts (or wherever Express app is created)
Ensure it calls `registerRoutes(app)` from routes.ts AFTER JSON middleware:
──────────────────────────────────────────────────────────────────────────────
import express from 'express';
import bodyParser from 'body-parser';
import { registerRoutes } from './routes';

const app = express();
app.use(bodyParser.json({ limit: '2mb' }));

registerRoutes(app);

// existing startup code (listen) remains the same
export default app;
──────────────────────────────────────────────────────────────────────────────

──────────────────────────────────────────────────────────────────────────────
AIRTABLE: MINIMAL FIELD MAP EXPECTATION

Contacts table fields (text unless noted):
- Name
- Email
- Phone
- Company
- Status  (single select: Active/Prospect/Unknown/Needs Review)

Meetings table fields:
- Name
- External Meeting ID
- Source        (single select: otter/manual)
- Idempotency Key
- Meeting Date  (date/time)
- Status        (single select: Processed/Needs Review/Failed)
- Contact       (link to Contacts)
- Transcript    (link to Transcripts)

Transcripts table fields:
- Title
- Content       (long text)
- Meeting Date  (date/time)
- Processing Status (single select: Processed/Needs Review)

──────────────────────────────────────────────────────────────────────────────
TEST QUICKLY (from your terminal)

# 1) Start the server, then:
curl -X POST http://localhost:3000/api/sync/ingest \
  -H "Content-Type: application/json" \
  -d '{
    "source":"otter",
    "externalMeetingId":"otter-12345",
    "title":"Discovery Call",
    "startISO":"2025-09-08T13:00:00Z",
    "attendees":[{"name":"Alex Smith","email":"alex@example.com","company":"Acme"}],
    "transcript":"Great meeting. Discussed scope and next steps.",
    "raw":{"zapId":"abc123","anything":"kept for review"}
  }'

# 2) Expect JSON with meetingRecordId/contactRecordId/transcriptRecordId.
# 3) Run again with the SAME payload: you should get a new Meeting row with the same “Idempotency Key”
#    (You can later enforce uniqueness in Airtable or de-dupe in your own DB if you mirror records.)

──────────────────────────────────────────────────────────────────────────────
“DONE” CHECKLIST

[ ] Ingest endpoint returns 200 with record IDs
[ ] Contact created/updated in Airtable (no dupes when same email)
[ ] Meeting row created with Idempotency Key populated
[ ] Transcript row created and linked to Meeting
[ ] If attendee has no email → Contact created with minimal fields + Status=Needs Review
[ ] Logs show correlationId across all steps

──────────────────────────────────────────────────────────────────────────────
NEXT SMALL IMPROVEMENTS (optional but easy)

- Enforce uniqueness in Airtable: add a computed “Uniq Key” = CONCATENATE(Source, ":", {External Meeting ID}, ":", DATETIME_FORMAT({Meeting Date}, 'X')) and use an automation to block dupes.
- Add /admin re-run flow: store the original payload in your DB (or Transcripts “Content Raw” field) and have /reprocess read + replay it through processMeeting.
- Normalize all times to UTC on write; render in user TZ on read (APP_TZ).

──────────────────────────────────────────────────────────────────────────────
NOTES

- This prompt avoids any new external dependencies—Node 18+ has global fetch.
- If your existing routes.ts already exports/registers routes, the patch section simply augments it.
- The code is intentionally defensive and minimal so you can ship quickly, then iterate.