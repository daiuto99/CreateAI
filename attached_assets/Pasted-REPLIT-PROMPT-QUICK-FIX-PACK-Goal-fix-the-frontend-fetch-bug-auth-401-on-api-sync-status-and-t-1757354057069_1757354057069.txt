REPLIT PROMPT — QUICK FIX PACK
Goal: fix the frontend fetch bug, auth 401 on /api/sync/status, and the “airtableService is not defined” error. Paste this entire prompt into Replit → Generate/Apply. It creates/patches only the files listed.

──────────────────────────────────────────────────────────────────────────────
1) FRONTEND: single API helper (fixes bad fetch method + sends cookies)

CREATE (or REPLACE) file: client/src/lib/api.ts
──────────────────────────────────────────────────────────────────────────────
export type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';

export async function apiRequest<T = any>(
  url: string,
  method: HttpMethod = 'GET',
  data?: unknown
): Promise<T> {
  const res = await fetch(url, {
    method,
    headers: data ? { 'Content-Type': 'application/json' } : undefined,
    body: data ? JSON.stringify(data) : undefined,
    credentials: 'include', // <-- IMPORTANT for session cookies
  });

  // Try to parse JSON, but include useful text if server returns non-JSON
  const text = await res.text();
  const json = (() => { try { return JSON.parse(text); } catch { return null; } })();

  if (!res.ok) {
    const detail = json ?? text;
    throw new Error(`API ${method} ${url} ${res.status}: ${typeof detail === 'string' ? detail : JSON.stringify(detail)}`);
  }
  return (json ?? ({} as T)) as T;
}

export const apiGet = <T=any>(url: string) => apiRequest<T>(url, 'GET');
export const apiPost = <T=any>(url: string, data?: unknown) => apiRequest<T>(url, 'POST', data);
export const apiPatch = <T=any>(url: string, data?: unknown) => apiRequest<T>(url, 'PATCH', data);
export const apiDel = <T=any>(url: string) => apiRequest<T>(url, 'DELETE');
──────────────────────────────────────────────────────────────────────────────

PATCH (or CREATE if missing): client/src/lib/queryClient.ts
(If you don’t have this file, you can skip. If you do, make sure URL is first.)
──────────────────────────────────────────────────────────────────────────────
import { apiRequest } from '@/lib/api';

// If you previously exported functions that took (method, url),
// change them to take (url, method) to avoid swapping arguments.
export const apiMutate = <T=any>(url: string, method: 'POST'|'PUT'|'PATCH'|'DELETE', data?: unknown) =>
  apiRequest<T>(url, method, data);

export const apiQuery = <T=any>(url: string) =>
  apiRequest<T>(url, 'GET');
──────────────────────────────────────────────────────────────────────────────

UPDATE CALL SITES where you mutate (example: client/src/pages/sync.tsx)
(Replace any usage like apiRequest('POST', '/api/sync/ingest', x) with URL-first)
──────────────────────────────────────────────────────────────────────────────
// BEFORE (WRONG):
// await apiRequest('POST', '/api/sync/ingest', payload);

// AFTER (RIGHT):
import { apiPost } from '@/lib/api';
await apiPost('/api/sync/ingest', payload);
──────────────────────────────────────────────────────────────────────────────

OPTIONAL: If frontend & backend run on different ports in dev, add a proxy.
PATCH: vite.config.ts  (only if needed)
──────────────────────────────────────────────────────────────────────────────
server: {
  proxy: {
    '/api': { target: 'http://localhost:5000', changeOrigin: true },
  },
},
──────────────────────────────────────────────────────────────────────────────


──────────────────────────────────────────────────────────────────────────────
2) BACKEND: auth middleware + status route (prevents 401 surprises)

PATCH: server/services/routes.ts
(Add a tiny auth helper, wire JSON parser once, and ensure /api/sync/status works)
──────────────────────────────────────────────────────────────────────────────
import type { Express, Request, Response, NextFunction } from 'express';
import bodyParser from 'body-parser';
import { registerSyncRoutes } from './sync'; // see section 3
import { getIntegrationHealth } from './integrationHealth'; // assumed existing

// Simple cookie/session-based auth gate. Adjust if you use another scheme.
function requireAuth(req: Request, res: Response, next: NextFunction) {
  // Accept either a server-side session (req.session.user) OR a Firebase-bridged user on req.user
  const user = (req as any).user || (req as any).session?.user;
  if (!user) return res.status(401).json({ message: 'Authentication required' });
  next();
}

export function registerRoutes(app: Express) {
  // Ensure JSON body parsing is applied once.
  app.use(bodyParser.json({ limit: '2mb' }));

  // --- STATUS for SYNC page (was 401 if cookie not sent) ---
  app.get('/api/sync/status', requireAuth, async (req: Request, res: Response) => {
    try {
      const health = await getIntegrationHealth(req);
      return res.json(health);
    } catch (e: any) {
      return res.status(500).json({ ok: false, error: e.message });
    }
  });

  // Add any other existing routes here…

  // Centralized place to add SYNC endpoints (/api/sync/ingest, /api/sync/reprocess, etc.)
  registerSyncRoutes(app, requireAuth);
}
──────────────────────────────────────────────────────────────────────────────


──────────────────────────────────────────────────────────────────────────────
3) BACKEND: fix “airtableService is not defined” and expose SYNC endpoints

PATCH: server/services/airtable-sync.ts
(Provide a safe factory that returns an Airtable service for the current user)
──────────────────────────────────────────────────────────────────────────────
import { getUserIntegration } from './integrationHealth'; // or wherever you read integrations
import { airtableClientFromApiKey } from './airtable';     // your existing Airtable wrapper

export interface AirtableService {
  contacts: {
    listAll: () => Promise<any[]>;
    findByEmail: (email: string) => Promise<any | null>;
    createOrUpdate: (fields: Record<string, any>, id?: string) => Promise<any>;
  };
  meetings: {
    create: (fields: Record<string, any>) => Promise<any>;
    linkToContact: (meetingId: string, contactId: string) => Promise<any>;
  };
  transcripts: {
    create: (fields: Record<string, any>) => Promise<any>;
    listCompleted?: () => Promise<any[]>; // optional
  };
}

export async function createAirtableServiceForRequest(req: any): Promise<AirtableService> {
  const userId = req?.session?.user?.id || req?.user?.id;
  if (!userId) throw new Error('No user for Airtable service');

  const integ = await getUserIntegration(userId, 'airtable');
  if (!integ?.hasCredentials) throw new Error('Airtable not connected');

  const { apiKey, baseId } = integ.credentials || {};
  const client = airtableClientFromApiKey(apiKey, baseId); // <- must exist in your airtable.ts

  return {
    contacts: {
      listAll: () => client.list('Contacts'),
      findByEmail: (email: string) => client.findOne('Contacts', { Email: email }),
      createOrUpdate: (fields, id) => client.upsert('Contacts', fields, id),
    },
    meetings: {
      create: (fields) => client.create('Meetings', fields),
      linkToContact: (meetingId, contactId) => client.update('Meetings', meetingId, { Contact: [contactId] }),
    },
    transcripts: {
      create: (fields) => client.create('Transcripts', fields),
      // listCompleted: () => client.query('Transcripts', { 'Processing Status': 'complete' }), // if you support filters
    },
  };
}
──────────────────────────────────────────────────────────────────────────────

PATCH: server/services/sync.ts
(Use the factory above; no naked airtableService references.)
──────────────────────────────────────────────────────────────────────────────
import type { Express, Request, Response } from 'express';
import { createAirtableServiceForRequest } from './airtable-sync';

function extractContactFromMeetingTitle(title?: string) {
  // very naive heuristic – replace with your smarter one
  if (!title) return null;
  const parts = title.split('|')[0].split(' ').map(s => s.trim()).filter(Boolean);
  const name = parts.length <= 3 ? parts.join(' ') : parts.slice(0, 2).join(' ');
  return { name };
}

export function registerSyncRoutes(app: Express, requireAuth: any) {
  // Ingest payload from Zap/Zapier/Otter
  app.post('/api/sync/ingest', requireAuth, async (req: Request, res: Response) => {
    try {
      const svc = await createAirtableServiceForRequest(req);

      const payload = req.body || {};
      const title = payload.title ?? 'Meeting';
      const contactGuess = extractContactFromMeetingTitle(title);
      let contactId: string | undefined;

      if (payload.email) {
        const existing = await svc.contacts.findByEmail(payload.email);
        if (existing?.id) contactId = existing.id;
      }

      if (!contactId && (payload.email || contactGuess)) {
        const result = await svc.contacts.createOrUpdate({
          Name: contactGuess?.name ?? payload.name ?? 'Unknown',
          Email: payload.email,
          Company: payload.company,
          Phone: payload.phone,
          Status: payload.email ? 'Prospect' : 'Needs Review',
        });
        contactId = result.records?.[0]?.id ?? result.id;
      }

      // Create transcript (optional)
      let transcriptId: string | undefined;
      if (payload.transcript || payload.raw) {
        const t = await svc.transcripts.create({
          Title: title,
          Content: payload.transcript ?? JSON.stringify(payload.raw ?? {}, null, 2),
          'Processing Status': 'Processed',
          'Meeting Date': payload.startISO ? new Date(payload.startISO).toISOString() : undefined,
        });
        transcriptId = t.records?.[0]?.id ?? t.id;
      }

      // Create meeting
      const m = await svc.meetings.create({
        Name: title,
        'External Meeting ID': payload.externalMeetingId,
        Source: payload.source ?? 'otter',
        'Meeting Date': payload.startISO ? new Date(payload.startISO).toISOString() : undefined,
        Transcript: transcriptId ? [transcriptId] : undefined,
      });
      const meetingId = m.records?.[0]?.id ?? m.id;

      // Link contact if present
      if (contactId) await svc.meetings.linkToContact(meetingId, contactId);

      return res.json({
        ok: true,
        meetingId,
        contactId,
        transcriptId,
      });
    } catch (e: any) {
      return res.status(500).json({ ok: false, error: e.message });
    }
  });

  // Optional: retry failed items later
  app.post('/api/sync/reprocess/:id', requireAuth, async (req: Request, res: Response) => {
    // Implement if you store raw payloads by id – stubbed for now:
    return res.json({ ok: true, reprocessed: req.params.id });
  });
}
──────────────────────────────────────────────────────────────────────────────


──────────────────────────────────────────────────────────────────────────────
4) BACKEND: airtable.ts must expose a small client (used above)

PATCH (or confirm): server/services/airtable.ts
(Expose airtableClientFromApiKey with list/findOne/create/update/upsert helpers)
──────────────────────────────────────────────────────────────────────────────
export function airtableClientFromApiKey(apiKey: string, baseId: string) {
  if (!apiKey || !baseId) throw new Error('Missing Airtable credentials');

  const API = 'https://api.airtable.com/v0';

  async function api(path: string, init: RequestInit = {}) {
    const res = await fetch(`${API}/${baseId}/${encodeURIComponent(path)}`, {
      ...init,
      headers: {
        Authorization: `Bearer ${apiKey}`,
        'Content-Type': 'application/json',
        ...(init.headers || {}),
      },
    });
    if (!res.ok) {
      const t = await res.text();
      throw new Error(`Airtable ${path} ${res.status}: ${t}`);
    }
    return res.json();
  }

  return {
    // Basic list
    list: async (table: string) => {
      const data = await api(table);
      return data.records ?? [];
    },
    // Basic “find one by exact field match” (first record)
    findOne: async (table: string, where: Record<string, string>) => {
      const [field, value] = Object.entries(where)[0];
      const formula = encodeURIComponent(`{${field}} = "${value}"`);
      const data = await api(`${table}?filterByFormula=${formula}`);
      return (data.records?.[0]) ?? null;
    },
    // Create a record
    create: (table: string, fields: Record<string, any>) =>
      api(table, { method: 'POST', body: JSON.stringify({ records: [{ fields }] }) }),
    // Update a record by id
    update: (table: string, id: string, fields: Record<string, any>) =>
      api(table, { method: 'PATCH', body: JSON.stringify({ records: [{ id, fields }] }) }),
    // Upsert by id (if provided)
    upsert: (table: string, fields: Record<string, any>, id?: string) =>
      id
        ? api(table, { method: 'PATCH', body: JSON.stringify({ records: [{ id, fields }] }) })
        : api(table, { method: 'POST', body: JSON.stringify({ records: [{ fields }] }) }),
  };
}
──────────────────────────────────────────────────────────────────────────────


──────────────────────────────────────────────────────────────────────────────
5) QUICK SELF-TESTS

A. Auth/session:
- From your UI flow, ensure `/api/auth/firebase-bridge` ran and you see “✅ Session saved …”.
- Calls from the browser MUST include cookies → we already set `credentials: 'include'` in the helper.

B. Hit status:
- In the browser console:
  fetch('/api/sync/status', { credentials: 'include' }).then(r => r.json()).then(console.log)

C. Ingest:
- From UI button or console:
  fetch('/api/sync/ingest', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    credentials: 'include',
    body: JSON.stringify({
      source: 'otter',
      externalMeetingId: 'otter-demo-123',
      title: 'Demo Meeting',
      startISO: new Date().toISOString(),
      email: 'someone@example.com',
      transcript: 'Test transcript from demo payload'
    })
  }).then(r => r.json()).then(console.log)

Expected: { ok: true, meetingId, contactId?, transcriptId? }

──────────────────────────────────────────────────────────────────────────────
WHAT THIS FIXES IN YOUR LOGS

✔ “Failed to execute 'fetch' … is not a valid HTTP method.”  
   → URL-first helper + correct call sites.

✔ “GET /api/sync/status 401 … Authentication required”  
   → requireAuth + credentials: 'include' from the frontend.

✔ “Failed to fetch transcripts from Airtable: airtableService is not defined”  
   → createAirtableServiceForRequest factory and proper imports in sync.ts.

(You can ignore the Airtable /meta/bases 403; your real Contacts/Meetings calls already succeed.)

END OF PROMPT
